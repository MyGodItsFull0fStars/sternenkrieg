% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

% This is a simple template for a LaTeX document using the "article" class.
% See "book", "report", "letter" for other types of document.

\documentclass[11pt]{article} % use larger type; default would be 10pt

\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)

%%% Examples of Article customizations
% These packages are optional, depending whether you want the features they provide.
% See the LaTeX Companion or other references for full information.

%%% PAGE DIMENSIONS
\usepackage{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (US) or a5paper or....
% \geometry{margin=2in} % for example, change the margins to 2 inches all round
% \geometry{landscape} % set up the page for landscape
%   read geometry.pdf for detailed page layout information

\usepackage{graphicx} % support the \includegraphics command and options

% \usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent

%%% PACKAGES
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
% These packages are all incorporated in the memoir class to one degree or another...

%%% HEADERS & FOOTERS
\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}

%%% SECTION TITLE APPEARANCE
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape} % (See the fntguide.pdf for font help)
% (This matches ConTeXt defaults)

%%% ToC (table of contents) APPEARANCE
\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC
\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % No bold!

%%% END Article customizations

%%% The "real" document content comes below...

\title{Sternenkrieg}
\author{Christian Bauer\\ xyz@edu.aau.at
\and Lukas Pagitz \\ xyz@edu.aau.at
\and Anja Ressmann \\ xyz@edu.aau.at
\and Christoph Roither \\ xyz@edu.aau.at
\and Boda Wen \\ xyz@edu.aau.at}
\date{21.06.2017}

% Eigene Änderungen
\usepackage[ngerman]{babel} % Silbentrennung
\setlength\parindent{0pt} %  keine Einrückung
\usepackage{graphicx}
\usepackage{float}
\usepackage[autostyle=true,german=quotes]{csquotes}
\usepackage{hyperref}

\begin{document}
\maketitle

\begin{center}
Software Engineering II - SS 16/17

\hfill \break

Univ.-Prof. Dipl.-Ing. Dr. Martin Pinzger

Univ.-Ass. Dipl.-Ing. Christian Macho

\hfill \break
\\[3em]
\begin{figure}[H]
	\centering
 	\includegraphics[width=1\textwidth]{img/main}
	\caption{Startbildschirm von Sternenkrieg}
\end{figure}
\end{center}
\hfill \break
\newpage
\tableofcontents

\newpage

\section{Einleitung}

Sternenkrieg <TODO>

\section{Grundlegender Aufbau}
\subsection{Spielablauf}
Sternenkrieg orientiert sich am Spielprinzip von "Schiffe versenken". Ziel ist es, die vom Gegner platzierten Schiffe als erster Spieler zu zerstören. Als Erweiterung zum herkömmlichen Spiel, bietet Sternenkrieg weitere Features, deren technische Funktionalität hier kurz erläutert wird. Dieses Kapitel soll zum Verständnis des Ablaufs im Programm beitragen.

Gestartet wird das Spiel mit einem Klick auf den Button "Play". Danach muss eine Verbindung zwischen beiden Spielern hergestellt werden. Hierzu ist es notwendig, dass sich die Smartphones beider Spieler im gleichen WLAN-Netzwerk befinden. Ein Spieler übernimmt im Spiel den Server, der andere übernimmt den Client.

Der Server-Spieler startet danach den Server und bekommt eine IP-Adresse angezeigt, welche er dem Client-Spieler übermittelt. Dieser verbindet sich damit zum Server. Sobald die Verbindung erfolgreich war, melden sich beide Spieler als bereit und das Spiel beginnt.

Um zu entscheiden, welcher der beiden Spieler das Spiel beginnen soll, muss gewürfelt werden. Dies geschieht durch Schütteln des Smartphones. Der Wert des jeweiligen Gegners wird dabei über das Netzwerk übertragen.

Nun beginnt das eigentliche Spiel: Jeder Spieler muss seine Schiffe (ein kleines, ein mittleres und ein großes) platzieren. Ziel des Gegners ist es nun, die Schiffe des Gegners zu zerstören, bevor die eigenen vernichtet werden.

Im weiteren Spielverlauf werden auch die besonderen Features von Sternenkrieg sichtbar. Diese sind unter anderem eine Schummelfunktion sowie ein PowerUp-System.

\subsection{Menüaufbau}
Das Menü von Sternenkrieg bietet - abgesehen vom eigentlichen Spiel - noch folgende Buttons:
\begin{itemize}
\item Highscore -- zeigt den Highscore von Sternenkrieg an
\item Optoins -- öffnet die Einstellungen des Spiels
\item About -- zeigt eine kurze About Us-Meldung an
\end{itemize}


\section{Klassen im Überblick}
In diesem Kapitel werden die allgemeinen Klassen und die dazugehörigen Activities von Sternenkrieg beschrieben. Besonders wichtige Klassen und Methoden werden ausführlicher behandelt.

\subsection{About}
Die Klasse "About" gibt einen kurzen Text über Sternenkrieg aus und hat sonst keine weitere Funktionalitäten.

\subsection{Dice}
Die Klasse "Dice" steht einen Würfel zur Verfügung. Dieser Würfel wird am Beginn des Spiels verwendet um den Beginner des Spiels zu bestimmen. Der Würfel wird außerdem bei den PowerUps verwendet, um eine Zufallszahl zu erhalten.
Das Würfeln erfolgt durch Schütteln des Smartphones. Hierfür wird ein SensorEvent-Listener verwendet. Unterstützt wird die Klasse Dice durch die Klasse res/Sensors.

Die Auswahl des korrekten Würfels (Spielstart oder PowerUps) erfolgt durch die Auswahl eines Modus (Variable mode). mode = 1 steht hierbei für den Spielstart, mode = 2 für das PowerUp-System.

\subsection{DiceClass}
Die Klasse "DiceClass" unterstützt den Würfel mit einigen ausgelagerten Methoden (Wechseln der Bilder und Abrufen der Variablen).

\subsection{Highscore}
Die Klasse "Highscore" zeigt den Highscore des Spiels an. Die Daten werden dabei aus der Klasse GameUtilities geholt.

\subsection{Main}
Die Klasse "Main" stellt den Startscreen sowie das Hauptmenü dar. Eingebunden werden hier das Hintergrundbild sowie die Buttons zur Menüauswahl. Falls das Spiel zum ersten Mal gestartet wird, muss vom Spieler ein Name eingegeben werden.

\subsection{MainSocket}
Die Klasse "MainSocket" wird nach Klick auf "Play" im Hauptmenü aufgerufen. In diesem Menü kann ein neues Spiel erstellt ("Server") bzw. einem Spiel beigetreten ("Client") werden.
Der Server-Spieler bekommt eine IP-Adresse angezeigt, welche er dem Client-Spieler übermittelt. Dieser gibt diese IP-Adresse ein und verbindet sich damit zum Server.

\subsection{Map}

\subsection{MapLoad}

\subsection{Options}
Die Klasse "Options" behandelt alle Einstellungsmöglichkeiten von Sternenkrieg. Dazu zählen:
\begin{itemize}
\item Name
\item Sound an/aus
\item Sprache (DE/EN)
\end{itemize}
Die Speicherung der Einstellungen erfolgt mithilfe von SharedPreferences ("prefs"). Diese bieten eine einfache Speicherung von Variablen, welche ebenfalls sehr einfach aktualisiert werden können. Nach einer Änderung wird die entsprechende Variable neu abgespeichert und steht somit auch den anderen Klassen zur Verfügung.

\subsection{PlayAudio}

\subsection{PowerUp}

\subsection{Spielfeld}

\section{GameLogic-Klassen im Überblick}
In diesem Kapitel werden die GameLogic-Klassen näher erläutert. Wie der Name schon sagt, beinhalten diese Klassen die eigentliche Spiellogik.

\subsection{FieldValues}

\subsection{GameUtilities}
Die Klasse "GameUtilities" verwaltet das Speichern der Informationen zum Spiel, darunter:
\begin{itemize}
\item Fortschritt
\item Highscore
\item Level
\item Sound an/aus
\item Username
\end{itemize}

Diese Informationen werden in den Shared Preferences "prefs" gespeichert. 

Die Klasse bietet unter anderem folgende Methoden:
\begin{itemize}
\item ArrayList<String> getHighscore() - liefert den aktuellen Highscore
\item void setHighscore() - setzt den aktuellen Highscore
\item void deleteHighscore() - löscht den Highscore

\item String getUsername() - liefert den gespeicherten Namen des Spielers
\item void setUsername(String username) - setzt einen neuen Namen (beim Start des Spiels bzw. in den Optionen)
\end{itemize}

\subsection{NetworkStats}

\subsection{PlayerFieldLogic}
In der Klasse "PlayerFieldLogic" wird die Logik des Spielfelds verwaltet. Die Spielfelddaten werden in einem String-Array playerField gespeichert.

Ähnlich wie die ShipLogic-Klasse besitzt auch diese Klasse mehrere Methoden, um die einzelnen Schiffsgrößen auf dem Spielfeld zu platzieren. Dies geschieht durch Übergabe der Position, des Winkels und eines Strings zur. Dabei wird bei den einzelnen Parametern überprüft, ob die Position der zu setzenden Felder gültig ist, ob der Winkel entweder horizontal oder vertikal ist und ob der String gültig ist.

\subsubsection{ContainsString}
Für die verschiedenen Schiffsgrößen existieren eigene ContrainsString-Methoden. Dabei werden Methoden aus der Klasse ShipLogic zur Überprüfung verwendet (inRange, getSibling, String != null).

\subsection{PlayerFieldShipContainer}
Um den Workflow und die Lesbarkeit zu erhöhen, werden die Klassen ShipLogic und PlayerFieldLogic in der Klasse "PlayerFieldShipContainer" zusammengeführt, um Arbeitsschritte zu verringern. Der Konstruktor beinhaltet genau diese beiden Klassen.

Es existieren drei setShipContainer-Methoden (für die drei Größen), wobei das jeweilige Schiff in beiden Klassen gesetzt wird.

\subsection{ShipLogic}
Die Klasse "ShipLogic" koopieriert mit der Klasse PlayerFieldLogic. In der Klasse ShipLogic werden die Schiffspositionen abgespeichert und bei Bedarf (z.B. beim Löschen der Schiffspositionen auf dem Spielfeld) abgerufen.

\subsubsection{Positionen der Schiffe}
Die Positionen der Schiffe werden in diesen Variablen gespeichert:
\begin{itemize}
\item int[] small\_ship
\item int[] middle\_ship
\item int[] big\_ship
\end{itemize}

Für alle Arrays stehen entsprechende get-Methoden zur Verfügung.

Die Position jedes Schiffes kann entweder über das Array gesetzt oder direkt als Position mit horizontalem/vertikalem Winkel angegeben werden. Der Winkel wird mit der Methode getSibling(int position) aufgerufen und übergibt den Abstand zu der Position.

\subsubsection{getSibling}
Die Methode int getSibling(int position) überprüft den übergebenen Parameter und liefert als Rückgabewert entweder 1 oder 8, welcher für die Positionierung der Siblings verwendet wird. Bei horizontaler Ausrichtung werden diese um eine Position versetzt auf das Spielfeld gesetzt, bei vertikaler Ausrichtung um 8 Positionen versetzt positioniert. Bei middleShip und bigShip wird stets mit dem Vorgänger-Sibling begonnen (position - sibling-Abstand bzw. position + sibling-Abstand).

\subsubsection{ShipIsSetOnField}
Schiffe können per Drag\&Drop auf dem Spielfeld platziert werden. Es existieren daher drei boolean-Variablen, welche angeben, ob ein Schiff bereits positioniert wurde oder nicht. Um zu prüfen, ob bereits alle Schiffe gesetzt wurden, steht die Methode allShipsSetOnPlayerField() zur Verfügung. Falls diese Methode true als Rückgabewert liefert, wird das ImageView in der Map-Activity auf aktiviert gesetzt und der Spieler kann fortfahren.

\subsubsection{inRange}
Diese Methode prüft, ob sich die übergegebenen Positionen innerhalb des Spielfelds befinden.

\section{Network-Klassen im Überblick}
Alle Netzwerk-bezogenen Klassen befinden sich im Package "network". Im Spiel Sternenkrieg übernimmt ein Spieler die Rolle des Servers, der andere die des Clients. Es wird sozusagen ein Server erstellt, zu welchem sich der Client verbindet. Im weiteren Spielverlauf spielt dies keine Rolle.

\subsection{AcceptThread}
Die Klasse "AcceptThread" stellt einen Thread für die Socket-Kommunikation zur Verfügung. In dieser Klasse wird der SocketServer erstellt (siehe StartThread für Socket).

\subsection{Client}
Die Klasse "Client" wird vom Client-Spieler geöffnet. Dieser verbindet sich mithilfe eines Threads per Socket zum Server. Wurde eine Verbindung hergestellt, kann der Server-Spieler das Spiel starten.

\subsection{Host}
Die Klasse "Host" wird vom Server-Spieler geöffnet. Dieser öffnet einen Socket (per Thread) und wartet anschließend auf die Verbindung vom Client. Die eigentlichen Spieldaten werden in der Klasse GameUtilities gespeichert.
Wurde die Verbindung erfolgreich hergestellt und das Spiel manuell vom Host gestartet, beginnt das Würfeln für den Spielstart.

\subsection{NetworkUtilities}
Die Klasse "NetworkUtilities" stellt die zentrale Schnittstelle für das Netzwerk dar und verbindet alle anderen Netzwerk-Klassen miteinander 

\subsection{ReceiveThreadClient/ReceiveThreadHost}
Die Klassen "ReceiveThreadClient" bzw. "ReceiveThreadHost" dienen zum Empfangen von Nachrichten über den Socket. Eine Klasse dient dabei für den Server-Spieler, die andere für den Client-Spieler. Write-Klassen: siehe WriteClient/WriteHost. 

\subsection{StartThread}
Die Klasse "StartThread" stellt einen Thread für die Socket-Kommunikation zur Verfügung. In dieser Klasse wird der eigentliche Socket erstellt (siehe AcceptThread für SocketServer).

\subsection{WriteClient/WriteHost}
Die Klassen "WriteClient" bzw. "WriteHost" dienen zum Senden von Text an den Client-Spieler bzw. an den Server-Spieler. Dabei wird die Nachricht über den entsprechenden Socket verschickt. Receive-Klassen: siehe ReceiveThreadClient/ReceiveThreadHost.

\section{Resources-Klassen im Überblick}

\subsection{animationClass}

\subsection{ErrorMessages}
Die Klasse "ErrorMessages" verwaltet zentrale Fehlermeldungen. In dieser Klasse werden nur Strings gespeichert.

\subsection{QRReader}

\subsection{Sensors}

\section{Erklärung besonderer Funktionen}

\subsection{Shared Preferences}

\section{Zusammenfassung}

\end{document}
